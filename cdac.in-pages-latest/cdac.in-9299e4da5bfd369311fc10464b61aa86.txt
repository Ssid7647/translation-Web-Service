#URL => https://cdac.in/index.aspx?id=print_page&print=DIViA1
DIViA
DIViA (Debugger with Integrated Visualizer and Analyzer) is an advanced portable and flexible parallel debugging environment.
It consists of a coherent set of tools that help programmers in both correctness and performance debugging.
Besides conventional logical debugging extended to parallel debugging, DIViA correctness debugger facilitates the visual debugging.
DIViA performance debugger detects the communication bottlenecks and quantifies the performance in terms of both computation and communication to help the user in fine tuning the parallel application.
DIViA is a complete debugging environment for enterprises that need to develop parallel applications using the message-passing paradigm.
Its software architecture provides a uniform interface to message passing programs written using various standard communication interfaces and makes it independent of the underlying processor architecture.
It works with MPI and debugs parallel applications developed using C or Fortran.
DIViA debugging environment consists of:
Correctness Debuggers
Multiprocess Debugger
Performance Debuggers
Automatic Communication Bottleneck Detector
Profile Visualizer
CORRECTNESS DEBUGGING
Correctness debugging of any program involves detection and fixation of causes (bugs), which result in incorrect behavior of the program.
In addition to the sequential program related issues the message passing (MP) parallel programs get affected by the synchronization between different constituent tasks and correctness of communication - in terms of both message data & order and contention for shared resources if any.
Often the causes for an incorrect MP program behavior are interrelated in complex fashion, and detecting the root cause needs filtering out all the secondary causes.
It facilitates a mechanism of Grouping Tasks using which multiple tasks can be viewed as a single entity and a sequential debugger command can be issued to all the constituent tasks of the group.
These aspects of DIViA correctness debugger makes it well suited for MP programs.
Ability to debug constituent tasks of a parallel and distributed application from a single control point
Supports the dynamic generation of task groups
Parallel analog to frequently used sequential debugger commands
Communication and execution oriented process status display
Selective debugger control of dynamically created tasks
Symbolic, interactive source code debugger for individual task
Flexible usage through pushbuttons and commands
PERFORMANCE DEBUGGING
Performance tuning of the message passing parallel applications is a challenging task.
DIViA helps users to tune their application by identifying both computation and communication bottlenecks.
The Profile Visualizer can easily detect the computational bottleneck region by systematic hierarchical analysis of the heap of profile data generated by parallel programs.
The other major cause of performance degradation is the message communication cost.
Detecting the source of a communication bottleneck conventionally requires browsing through all the communication events in a parallel program, with the help of event traces and visualization tools.
Since this is not practical in most real parallel programs, DIViA provides automatic detection of communication bottlenecks.
It adopts a two-pass trace collection and filtering technique to zero in on the bottleneck regions.
It also provides ways of visualizing the bottleneck regions graphically and provides means to relate the causes of performance degradation to their sources.
Hierarchical data representation
Different performance analysis views using Task Graph, Gantt chart and Source Code View
User selectable filters to mask irrelevant data
Automatic Communication bottleneck Detector
Automatically detects Communication Bottleneck
Provision to hierarchically pinpoint the actual region of bottleneck
Minimum perturbation to the user application because traces are generated only for the selected task and selected regions
Task Graph to know the details of each task's communication
Space Time Diagram to see the communication events in the bottleneck region
Source Code View corresponding to the event in the bottleneck region
Minimum analysis time because of the bucket generation concepts
No huge tracefiles even for large user applications
Static instrumentation method to collect event traces
Independent trace collection and analysis
Availability
Supported Hardware
Workstation Clusters (32 bit and 64bit)
Supported Operating System
AIX, Solaris and Linux
User Interfaces
GUI
Supported Languages
Fortran and C
Prerequisite Software
Java, X/Motif, MPI
header
